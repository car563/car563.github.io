<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Lab: Pro Edition</title>
    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-bg: rgba(15, 23, 42, 0.85);
            --text-color: #f8fafc;
            --accent: #38bdf8;
            --danger: #ef4444;
            --border: rgba(56, 189, 248, 0.3);
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', system-ui, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* Modern Glassmorphism UI */
        #ui-left {
            position: absolute;
            top: 20px;
            left: 20px;
            background: var(--panel-bg);
            color: var(--text-color);
            padding: 20px;
            border-radius: 16px;
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            pointer-events: auto;
            z-index: 10;
            min-width: 240px; /* Slightly wider for buttons */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            
            /* NEW: Collapsible Animation (Like Spawn Menu) */
            max-height: 60px; /* Collapsed height just enough for title */
            overflow: hidden;
            transition: max-height 0.4s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.3s, box-shadow 0.3s;
            cursor: pointer;
        }

        /* NEW: Expand on Hover */
        #ui-left:hover {
            max-height: 85vh; /* Expand to fit content */
            overflow-y: auto; /* Enable scroll if needed */
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
            background: rgba(15, 23, 42, 0.95);
        }

        /* NEW: Scrollbar for Main Menu */
        #ui-left::-webkit-scrollbar {
            width: 6px;
        }
        #ui-left::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin: 10px 0;
        }
        #ui-left::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        #ui-left::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* --- HOME MENU STYLES --- */
        #home-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(15, 23, 42, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(8px);
            transition: opacity 0.3s ease, visibility 0.3s;
        }

        #home-menu.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .title-large {
            font-size: 3.5rem;
            color: var(--accent);
            font-weight: 900;
            margin-bottom: 2rem;
            text-transform: uppercase;
            letter-spacing: 6px;
            text-shadow: 0 0 30px rgba(56, 189, 248, 0.4);
            text-align: center;
        }

        .play-btn {
            font-size: 1.8rem;
            padding: 18px 60px;
            background: var(--accent);
            color: #0f172a;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.4);
        }

        .play-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 40px rgba(56, 189, 248, 0.6);
            background: #fff;
        }

        .menu-hint {
            color: #94a3b8;
            margin-top: 30px;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        /* NEW: Crash Warning Style */
        .crash-warning {
            position: absolute;
            bottom: 30px;
            color: #ef4444;
            font-size: 0.8rem;
            opacity: 0.7;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-weight: bold;
        }

        /* Hide game UI when menu is open */
        body.menu-active #ui-left,
        body.menu-active #fps-counter,
        body.menu-active #item-counter,
        body.gui-hidden #ui-left {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        /* NEW: FPS Counter Styles */
        #fps-counter {
            position: absolute;
            top: 6px;
            left: 24px;
            color: rgba(248, 250, 252, 0.4);
            font-family: monospace;
            font-size: 11px;
            font-weight: bold;
            z-index: 50;
            pointer-events: none;
            letter-spacing: 1px;
        }

        /* NEW: Item Counter Styles */
        #item-counter {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(248, 250, 252, 0.6);
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
            z-index: 50;
            pointer-events: none;
            letter-spacing: 1px;
            background: rgba(15, 23, 42, 0.6);
            padding: 8px 12px;
            border-radius: 8px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(56, 189, 248, 0.2);
            transition: opacity 0.3s;
        }

        h1 {
            margin: 0 0 8px 0;
            font-size: 1.1rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 800;
            /* NEW: Flex layout for the arrow */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* NEW: Arrow indicator for Main Menu */
        h1::after {
            content: '‚ñº';
            font-size: 0.8em;
            transition: transform 0.4s;
            color: rgba(255,255,255,0.5);
        }

        #ui-left:hover h1::after {
            transform: rotate(180deg);
            color: var(--accent);
        }

        /* Spawn Button Grid Styles */
        .spawn-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .spawn-btn {
            background: linear-gradient(145deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.01) 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #ccc;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            text-align: left;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
            font-weight: 500;
            width: 100%;
            box-sizing: border-box;
        }

        .spawn-btn:hover {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
            transform: translateX(5px);
            font-weight: 700;
        }

        .spawn-btn.clear {
            margin-top: 8px;
            border-color: rgba(239, 68, 68, 0.3);
            color: var(--danger);
        }

        .spawn-btn.clear:hover {
            background: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        .key-hint {
            font-size: 0.75rem;
            color: #94a3b8;
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .key-box {
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            color: white;
        }

        /* Fancy Slider */
        .control-group {
            margin-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 15px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin-bottom: 8px;
            font-weight: 600;
            color: #e2e8f0;
        }

        /* NEW: Editable Values CSS */
        .editable-val {
            cursor: text;
            border-bottom: 1px dashed rgba(255,255,255,0.3);
            transition: border-color 0.2s;
        }
        .editable-val:hover {
            border-bottom-color: var(--accent);
            color: white;
        }
        .value-input {
            width: 60px;
            background: #1e293b;
            border: 1px solid var(--accent);
            color: var(--text-color);
            border-radius: 4px;
            padding: 2px 5px;
            font-family: inherit;
            font-size: 0.9rem;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            appearance: none;
        }

        input[type=range]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            border: 2px solid #0f172a;
            box-shadow: 0 0 10px var(--accent);
        }

        canvas {
            display: block;
            cursor: crosshair;
        }
    </style>
</head>
<body class="menu-active">

<!-- HOME MENU OVERLAY -->
<div id="home-menu">
    <div class="title-large">Physics Lab</div>
    <button class="play-btn" onclick="togglePause()">PLAY</button>
    <div class="menu-hint">Press <b>ESC</b> to Pause / Resume</div>
    <div class="crash-warning">Dont get mad at me if you're PC crashes!</div>
</div>

<!-- NEW: FPS Counter Element -->
<div id="fps-counter">FPS: 60</div>
<!-- NEW: Item Counter Element -->
<div id="item-counter">Items: 0</div>

<div id="ui-left">
    <h1>Physics Lab</h1>
    <p style="font-size: 0.85rem; color: #cbd5e1;">Advanced AI Enabled.</p>
    
    <!-- CONTROLS LIST -->
    <div class="key-hint"><span class="key-box">Click x5</span> or <b>Slam</b> to explode</div>
    <div class="key-hint"><span class="key-box">E</span> Quick Spawn (Hold for stream)</div>
    <div class="key-hint"><span class="key-box">3</span> Explode Everything</div>
    <div class="key-hint"><span class="key-box">F</span> Fire Blasters</div>
    <div class="key-hint"><span class="key-box">M</span> Toggle UI</div>
    <div class="key-hint"><span class="key-box">T</span> Slow Motion</div>
    <div class="key-hint"><span class="key-box">2</span> Clear World</div>
    <div class="key-hint"><span class="key-box">WASD</span> or <span class="key-box">‚Üê ‚Üí</span> Drive / Aim</div>
    <div class="key-hint"><span class="key-box">ESC</span> Pause Menu</div>

    <div class="control-group">
        <div class="slider-label">
            <span>Gravity</span>
            <span id="gravity-val" class="editable-val">1.5</span>
        </div>
        <input type="range" id="gravity-slider" min="-2" max="5" step="0.1" value="1.5">
    </div>

    <!-- NEW: Size Slider -->
    <div class="control-group">
        <div class="slider-label">
            <span>Spawn Size</span>
            <span id="size-val" class="editable-val">1.0x</span>
        </div>
        <!-- UPDATED: min to 0.1, max to 5 -->
        <input type="range" id="size-slider" min="0.1" max="5" step="0.1" value="1.0">
    </div>

    <!-- NEW: Spawn Count Slider -->
    <div class="control-group">
        <div class="slider-label">
            <span>Spawn Count</span>
            <span id="count-val" class="editable-val">1</span>
        </div>
        <input type="range" id="count-slider" min="1" max="20" step="1" value="1">
    </div>

    <!-- NEW: Item Limit Toggle -->
    <div class="control-group" style="display: flex; align-items: center; justify-content: space-between;">
        <span class="slider-label" style="margin: 0;">Item Limit (Anti-Lag)</span>
        <input type="checkbox" id="limit-toggle" checked style="accent-color: var(--accent); width: 16px; height: 16px; cursor: pointer;">
    </div>

    <!-- NEW: FPS Slider -->
    <div class="control-group">
        <div class="slider-label">
            <span>Max FPS</span>
            <span id="fps-val" class="editable-val">60</span>
        </div>
        <input type="range" id="fps-slider" min="30" max="150" step="30" value="60">
    </div>

    <!-- NEW: Explosion Power Slider -->
    <div class="control-group">
        <div class="slider-label">
            <span>Boom Power</span>
            <span id="power-val" class="editable-val">1.0x</span>
        </div>
        <input type="range" id="power-slider" min="0.1" max="100.0" step="0.1" value="1.0">
    </div>

    <!-- NEW: Explosion Range Slider -->
    <div class="control-group">
        <div class="slider-label">
            <span>Boom Range</span>
            <span id="range-val" class="editable-val">600</span>
        </div>
        <input type="range" id="range-slider" min="100" max="100000" step="50" value="600">
    </div>

    <!-- MOVED: Spawn Buttons Section -->
    <div class="control-group">
        <div class="slider-label" style="color: var(--accent); text-transform: uppercase; letter-spacing: 1px;">Tools & Objects</div>
        <div class="spawn-grid">
            <button class="spawn-btn" onclick="selectAndSpawn('block')">üì¶ Crate</button>
            <button class="spawn-btn" onclick="selectAndSpawn('heavy')">ü™® Heavy Metal</button>
            <button class="spawn-btn" onclick="selectAndSpawn('blackhole')">‚ö´ Black Hole</button>
            <button class="spawn-btn" onclick="selectAndSpawn('ball')">üé± Sphere</button>
            <button class="spawn-btn" onclick="selectAndSpawn('water')">üíß Water</button>
            <button class="spawn-btn" onclick="selectAndSpawn('car')">üèéÔ∏è Sport Car</button>
            <button class="spawn-btn" onclick="selectAndSpawn('person')">üèÉ Ragdoll (AI)</button>
            <button class="spawn-btn" onclick="selectAndSpawn('launcher')">üî´ Blaster</button>
            <button class="spawn-btn" onclick="selectAndSpawn('delete')" style="border-color: #ef4444; color: #ef4444;">‚ùå Delete Tool</button>
            <button class="spawn-btn clear" onclick="clearAllShapes()">üóëÔ∏è Clear World (2)</button>
        </div>
    </div>
</div>

<script>
    // --- Audio Context Setup ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    function resumeAudio() {
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }
    document.addEventListener('mousedown', resumeAudio, { once: true });
    document.addEventListener('keydown', resumeAudio, { once: true });

    // --- NEW: ADVANCED AUDIO SYSTEM ---
    function playImpactSound(speed, type) {
        if (audioCtx.state === 'suspended') return;
        // Don't play sound for tiny bumps
        if (speed < 1.5) return;

        const t = audioCtx.currentTime;
        const vol = Math.min(0.8, (speed - 1.5) / 15); // Volume scales with speed

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(vol, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        gain.connect(audioCtx.destination);

        if (type === 'metal') {
            // STEEL CLANG (Improved FM Synthesis)
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const modGain = audioCtx.createGain();
            
            // Higher base pitch for "Steel" (800Hz range)
            const baseFreq = 800 + Math.random() * 400;
            
            osc1.type = 'sine'; // Carrier: Sine gives a clean "ring"
            osc1.frequency.setValueAtTime(baseFreq, t);
            
            osc2.type = 'square'; // Modulator: Square adds harsh metallic harmonics
            osc2.frequency.setValueAtTime(baseFreq * 1.4, t); // Inharmonic ratio
            
            // Modulation Depth (The "Clang")
            modGain.gain.setValueAtTime(1000, t); 
            modGain.gain.exponentialRampToValueAtTime(10, t + 0.3); // Sharp attack fades to pure ring
            
            osc2.connect(modGain);
            modGain.connect(osc1.frequency);
            osc1.connect(gain);
            
            osc1.start(t); osc2.start(t);
            osc1.stop(t + 0.5); osc2.stop(t + 0.5); // Longer ring for steel
        } else {
            // WOOD/DEFAULT THUD (Filtered Noise)
            const bufferSize = audioCtx.sampleRate * 0.1;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            // Harder hits = Brighter sound
            filter.frequency.setValueAtTime(200 + (speed * 50), t);
            filter.Q.value = 1;

            noise.connect(filter);
            filter.connect(gain);
            noise.start(t);
        }
    }

    function playExplosionSound() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const t = audioCtx.currentTime;

        // 1. Noise Burst (The "Crunch") - LOUDER AND PUNCHIER
        const bufferSize = audioCtx.sampleRate * 0.6; 
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = (Math.random() * 2 - 1) * (1 - i/bufferSize); // Decay built-in
        }

        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        
        const noiseFilter = audioCtx.createBiquadFilter();
        noiseFilter.type = 'lowpass';
        noiseFilter.frequency.setValueAtTime(1000, t);
        noiseFilter.frequency.exponentialRampToValueAtTime(100, t + 0.4);
        
        const noiseGain = audioCtx.createGain();
        noiseGain.gain.setValueAtTime(0.8, t);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(audioCtx.destination);
        noise.start();

        // 2. Sub-Bass Impact (The "Thump")
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(80, t);
        osc.frequency.exponentialRampToValueAtTime(10, t + 0.5); // Drop pitch fast

        const oscGain = audioCtx.createGain();
        oscGain.gain.setValueAtTime(1.0, t);
        oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

        osc.connect(oscGain);
        oscGain.connect(audioCtx.destination);
        osc.start();
        osc.stop(t + 0.5);
    }
    
    function playShootSound() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const t = audioCtx.currentTime;
        
        const osc = audioCtx.createOscillator();
        osc.type = 'sawtooth'; // More aggressive
        osc.frequency.setValueAtTime(600, t);
        osc.frequency.exponentialRampToValueAtTime(100, t + 0.15); 
        
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.15, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
        
        // Highpass to remove muddy low end
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 500;

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(t + 0.15);
    }

    const { Engine, Render, Runner, Bodies, Composite, MouseConstraint, Mouse, Vector, Events, Body, Constraint } = Matter;

    const engine = Engine.create({
        positionIterations: 5, // Improved stability for impact sounds
        velocityIterations: 4
    });
    const world = engine.world;
    engine.gravity.y = 1.5;

    // Use a high pixel ratio for sharpness
    const render = Render.create({
        element: document.body,
        engine: engine,
        options: {
            width: window.innerWidth,
            height: window.innerHeight,
            wireframes: false, 
            background: '#0f172a',
            pixelRatio: window.devicePixelRatio || 1
        }
    });

    // --- GAME STATE MANAGEMENT ---
    let isGameRunning = false;
    let isSlowMotion = false; 
    const homeMenu = document.getElementById('home-menu');
    
    // NEW: VFX Variables
    const vfx = []; // Stores active visual effects
    let shakeIntensity = 0; // Screen shake

    // NEW: Custom Game Loop Variables
    let lastTime = 0;
    let animationFrameId = null;

    // NEW: FPS Control Variables
    let targetFPS = 60;
    let frameInterval = 1000 / targetFPS;
    let lastRenderTime = 0;

    function gameLoop(time) {
        if (!isGameRunning) return;
        
        animationFrameId = requestAnimationFrame(gameLoop);

        if (!lastTime) {
            lastTime = time;
            lastRenderTime = time;
            return;
        }

        // FPS THROTTLING
        if (targetFPS < 150) {
            const elapsed = time - lastRenderTime;
            if (elapsed < frameInterval) return; 
            lastRenderTime = time - (elapsed % frameInterval);
        }

        const dt = time - lastTime;
        lastTime = time;
        const safeDt = Math.min(dt, 100);
        const timeScale = isSlowMotion ? 0.2 : 1.0;
        const scaledDt = safeDt * timeScale;

        // Update Physics
        Engine.update(engine, scaledDt);
        
        // NEW: Screen Shake Logic
        const ctx = render.context;
        ctx.save();
        if (shakeIntensity > 0) {
            const shakeX = (Math.random() - 0.5) * shakeIntensity;
            const shakeY = (Math.random() - 0.5) * shakeIntensity;
            ctx.translate(shakeX, shakeY);
            shakeIntensity *= 0.9; // Decay
            if (shakeIntensity < 0.5) shakeIntensity = 0;
        }

        // Render Frame
        Render.world(render);
        
        // Restore context (End Shake)
        ctx.restore();
    }

    function togglePause() {
        isGameRunning = !isGameRunning;
        
        if (isGameRunning) {
            // Resume
            homeMenu.classList.add('hidden');
            document.body.classList.remove('menu-active');
            
            // Reset timers
            lastTime = 0;
            lastRenderTime = 0;
            // Start Loop
            animationFrameId = requestAnimationFrame(gameLoop);
            
            if (audioCtx.state === 'suspended') audioCtx.resume();
        } else {
            // Pause
            homeMenu.classList.remove('hidden');
            document.body.classList.add('menu-active');
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
    }

    // --- High Quality Walls ---
    const wallOptions = { isStatic: true, render: { fillStyle: '#1e293b' }, friction: 0.8, restitution: 0.5 };
    let ground, leftWall, rightWall, ceiling;

    function createWalls() {
        const bodies = Composite.allBodies(world);
        const wallsToRemove = bodies.filter(b => b.isStatic && b.customType !== 'blackhole'); 
        Composite.remove(world, wallsToRemove);

        const thick = 100;
        const w = window.innerWidth;
        const h = window.innerHeight;
        
        ground = Bodies.rectangle(w / 2, h + thick/2, w, thick, wallOptions);
        leftWall = Bodies.rectangle(-thick/2, h / 2, thick, h, wallOptions);
        rightWall = Bodies.rectangle(w + thick/2, h / 2, thick, h, wallOptions);
        ceiling = Bodies.rectangle(w / 2, -thick/2, w, thick, wallOptions);
        
        Composite.add(world, [ground, leftWall, rightWall, ceiling]);
    }
    createWalls();

    const palette = ['#fbbf24', '#f87171', '#c084fc', '#4ade80', '#60a5fa', '#f472b6'];

    // --- GLOBAL SPAWN SELECTION ---
    let currentSpawnType = 'block';
    let spawnScale = 1.0; 
    // NEW: Global Explosion Settings
    let explosionPower = 1.0;
    let explosionRange = 600;

    function selectAndSpawn(type) {
        currentSpawnType = type;
        if (type !== 'delete') {
            spawnEntity(type);
        }
    }

    function spawnEntity(type, x, y) {
        const posX = (x !== undefined) ? x : (window.innerWidth / 2 + (Math.random() * 600 - 300));
        const posY = (y !== undefined) ? y : (window.innerHeight - 150);
        
        const color = palette[Math.floor(Math.random() * palette.length)];
        const timestamp = Date.now();
        const groupId = Math.random().toString(36).substr(2, 9); 

        const commonProps = {
            isTarget: true,
            tapCount: 0,
            createdAt: timestamp,
            groupId: groupId,
            entityType: type 
        };

        const s = (type === 'person') ? 1.0 : spawnScale;
        const densityScale = s; 
        const dragScale = 1 / Math.max(0.1, s);

        try {
            if (type === 'block') {
                const size = 60 * s; 
                const b = Bodies.rectangle(posX, posY, size, size, { 
                    render: { fillStyle: color }, 
                    chamfer: { radius: 4 * s }, 
                    restitution: 0.4,
                    frictionAir: 0.01 * dragScale,
                    density: 0.001 * densityScale
                });
                Object.assign(b, commonProps);
                b.customType = 'crate';
                Composite.add(world, b);
            } 
            else if (type === 'heavy') {
                const size = 60 * s;
                const b = Bodies.rectangle(posX, posY, size, size, { 
                    render: { fillStyle: '#64748b' }, 
                    chamfer: { radius: 2 * s }, 
                    restitution: 0.1, 
                    density: 50 * densityScale, 
                    friction: 0.6,
                    frictionAir: 0.005 * dragScale
                });
                Object.assign(b, commonProps);
                b.customType = 'heavyBlock';
                Composite.add(world, b);
            }
            else if (type === 'blackhole') {
                const b = Bodies.circle(posX, posY, 30 * s, {
                    render: { fillStyle: '#000000' },
                    density: 100 * densityScale, 
                    frictionAir: 0.1 * dragScale, 
                    restitution: 0,
                    isStatic: false 
                });
                Object.assign(b, commonProps);
                b.customType = 'blackhole';
                Composite.add(world, b);
            }
            else if (type === 'ball') {
                const r = 30 * s;
                const b = Bodies.circle(posX, posY, r, { 
                    render: { fillStyle: color }, 
                    restitution: 0.8,
                    friction: 0.005,
                    frictionAir: 0.005 * dragScale,
                    density: 0.001 * densityScale
                });
                Object.assign(b, commonProps);
                b.customType = 'sphere';
                Composite.add(world, b);
            }
            else if (type === 'water') {
                const r = (5 + Math.random() * 2) * s; 
                const b = Bodies.circle(posX, posY, r, {
                    render: { fillStyle: 'rgba(56, 189, 248, 0.6)' },
                    friction: 0.0,       
                    frictionStatic: 0.0, 
                    frictionAir: 0.001,  
                    restitution: 0.0,    
                    density: 0.005,      
                    slop: 0.1            
                });
                Body.setVelocity(b, { x: (Math.random() - 0.5) * 5, y: (Math.random() - 0.5) * 5 });
                Object.assign(b, commonProps);
                b.customType = 'water';
                Composite.add(world, b);
            }
            else if (type === 'car') {
                const group = Body.nextGroup(true);
                const chassis = Bodies.rectangle(posX, posY, 100 * s, 20 * s, { 
                    collisionFilter: { group: group },
                    render: { fillStyle: color },
                    chamfer: { radius: 5 * s },
                    density: 0.02 
                });
                const cabin = Bodies.trapezoid(posX, posY - 25 * s, 60 * s, 30 * s, 0.3, {
                    collisionFilter: { group: group },
                    render: { fillStyle: '#1e293b' },
                    density: 0.005 
                });
                const body = Body.create({ parts: [chassis, cabin] });
                
                const wheelSize = 16 * s;
                const wheelOptions = { 
                    collisionFilter: { group: group },
                    friction: 1.0,   
                    restitution: 0,  
                    render: { fillStyle: '#333' },
                    density: 0.05    
                };
                
                const wheel1 = Bodies.circle(posX - 35 * s, posY + 15 * s, wheelSize, wheelOptions);
                const wheel2 = Bodies.circle(posX + 35 * s, posY + 15 * s, wheelSize, wheelOptions);
                
                const axel1 = Constraint.create({ 
                    bodyA: body, pointA: { x: -35 * s, y: 15 * s }, 
                    bodyB: wheel1, pointB: { x: 0, y: 0 }, 
                    stiffness: 0.2, damping: 0.1, length: 0, render: { visible: false } 
                });
                const axel2 = Constraint.create({ 
                    bodyA: body, pointA: { x: 35 * s, y: 15 * s }, 
                    bodyB: wheel2, pointB: { x: 0, y: 0 }, 
                    stiffness: 0.2, damping: 0.1, length: 0, render: { visible: false } 
                });
                
                [body, wheel1, wheel2].forEach(p => Object.assign(p, commonProps));
                body.customType = 'carBody';
                wheel1.customType = 'wheel'; wheel2.customType = 'wheel';
                body.wheels = [wheel1, wheel2];
                body.driver = null;

                Composite.add(world, [body, wheel1, wheel2, axel1, axel2]);
            }
            else if (type === 'person') {
                const group = Body.nextGroup(true);
                const startY = posY;
                const head = Bodies.circle(posX, startY - 25, 12, { collisionFilter: { group: group }, render: { fillStyle: '#ffccaa' } });
                const torso = Bodies.rectangle(posX, startY + 10, 24, 40, { collisionFilter: { group: group }, render: { fillStyle: color }, chamfer: { radius: 5 } });
                const rightArm = Bodies.rectangle(posX + 18, startY + 5, 8, 30, { collisionFilter: { group: group }, render: { fillStyle: color }, chamfer: { radius: 3 } });
                const leftArm = Bodies.rectangle(posX - 18, startY + 5, 8, 30, { collisionFilter: { group: group }, render: { fillStyle: color }, chamfer: { radius: 3 } });
                const rightLeg = Bodies.rectangle(posX + 8, startY + 45, 10, 35, { collisionFilter: { group: group }, render: { fillStyle: '#334155' }, chamfer: { radius: 3 } });
                const leftLeg = Bodies.rectangle(posX - 8, startY + 45, 10, 35, { collisionFilter: { group: group }, render: { fillStyle: '#334155' }, chamfer: { radius: 3 } });

                const neck = Constraint.create({ bodyA: head, bodyB: torso, pointA: { x: 0, y: 12 }, pointB: { x: 0, y: -20 }, stiffness: 0.5, render: { visible: false } });
                const armRA = Constraint.create({ bodyA: torso, bodyB: rightArm, pointA: { x: 12, y: -10 }, pointB: { x: 0, y: -12 }, stiffness: 0.5, render: { visible: false } });
                const armLA = Constraint.create({ bodyA: torso, bodyB: leftArm, pointA: { x: -12, y: -10 }, pointB: { x: 0, y: -12 }, stiffness: 0.5, render: { visible: false } });
                const legRA = Constraint.create({ bodyA: torso, bodyB: rightLeg, pointA: { x: 8, y: 20 }, pointB: { x: 0, y: -15 }, stiffness: 0.5, render: { visible: false } });
                const legLA = Constraint.create({ bodyA: torso, bodyB: leftLeg, pointA: { x: -8, y: 20 }, pointB: { x: 0, y: -15 }, stiffness: 0.5, render: { visible: false } });

                [head, torso, rightArm, leftArm, rightLeg, leftLeg].forEach(p => Object.assign(p, commonProps));
                head.customType = 'face'; 
                torso.customType = 'ragdoll';
                
                const personalities = ['social', 'explorer', 'timid'];
                const pType = personalities[Math.floor(Math.random() * personalities.length)];
                
                torso.ai = {
                    state: 'walk',
                    personality: pType, 
                    direction: Math.random() > 0.5 ? 1 : -1,
                    nextActionTime: 0,
                    isStuckCount: 0,
                    socialCooldown: 0,
                    talkDuration: 0,
                    talkText: '',
                    fearTarget: null, 
                    targetBody: null, 
                    vehicle: null, 
                    seatbelt: null 
                };
                
                head.relatedTorso = torso;
                torso.relatedHead = head;
                torso.legs = { right: rightLeg, left: leftLeg };
                torso.allParts = [head, torso, rightArm, leftArm, rightLeg, leftLeg];

                Composite.add(world, [head, torso, rightArm, leftArm, rightLeg, leftLeg, neck, armRA, armLA, legRA, legLA]);
            }
            else if (type === 'launcher') {
                // NEW: Generate a unique collision group so bullets don't hit the gun
                const group = Body.nextGroup(true);

                const gunBody = Bodies.rectangle(posX, posY, 60 * s, 20 * s, {
                    render: { fillStyle: '#475569' },
                    chamfer: { radius: 4 * s },
                    density: 0.05 * densityScale, 
                    frictionAir: 0.05 * dragScale,
                    collisionFilter: { group: group } // Assign group
                });
                const handle = Bodies.rectangle(posX - 15 * s, posY + 15 * s, 15 * s, 30 * s, {
                    render: { fillStyle: '#334155' },
                    chamfer: { radius: 2 * s },
                    density: 0.05 * densityScale,
                    collisionFilter: { group: group } // Assign group
                });
                const body = Body.create({ parts: [gunBody, handle] });
                
                Object.assign(body, commonProps);
                body.frictionAir = 0.05 * dragScale; 
                body.customType = 'launcher';
                body.collisionGroup = group; // Store group for bullets
                body.launcher = { lastShot: 0, cooldown: 150 }; 
                
                Composite.add(world, body);
            }
        } catch (e) {
            console.error("Spawn error:", e);
        }
    }

    // --- HELPER: Fire a single launcher ---
    function fireLauncher(launcher) {
        const now = Date.now();
        if (now - launcher.launcher.lastShot < launcher.launcher.cooldown) return;
        
        launcher.launcher.lastShot = now;
        playShootSound();
        
        const approximateScale = (launcher.bounds.max.x - launcher.bounds.min.x) / 75; 
        
        const len = 35 * approximateScale;
        const angle = launcher.angle;
        const barrelX = launcher.position.x + Math.cos(angle) * len;
        const barrelY = launcher.position.y + Math.sin(angle) * len;
        
        const projectile = Bodies.circle(barrelX, barrelY, 6, {
            density: 0.05,
            restitution: 0.5,
            render: { fillStyle: '#ef4444' },
            // NEW: Inherit collision group so it passes through the gun
            collisionFilter: { group: launcher.collisionGroup }
        });
        
        const force = 0.4;
        Body.applyForce(projectile, projectile.position, {
            x: Math.cos(angle) * force,
            y: Math.sin(angle) * force
        });
        
        projectile.isTarget = true; 
        projectile.tapCount = 5; 
        projectile.groupId = Math.random().toString(36).substr(2, 9);
        projectile.entityType = 'projectile';
        projectile.trail = []; 
        
        Composite.add(world, projectile);
        
        Body.applyForce(launcher, launcher.position, {
            x: -Math.cos(angle) * 0.05,
            y: -Math.sin(angle) * 0.05
        });
    }

    // --- INPUT TRACKING ---
    const keys = {};
    window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

    // --- AI SYSTEM LOOP ---
    Events.on(engine, 'beforeUpdate', function(event) {
        const bodies = Composite.allBodies(world);
        const time = engine.timing.timestamp;
        
        const fallenBodies = bodies.filter(b => b.position.y > window.innerHeight + 1000);
        if (fallenBodies.length > 0) {
            Composite.remove(world, fallenBodies);
        }

        if (isLimitActive) {
            const dynamicBodies = bodies.filter(b => !b.isStatic && b.customType !== 'blackhole');
            if (dynamicBodies.length > 3000) {
                const toRemove = dynamicBodies.slice(0, 5); 
                const safeToRemove = toRemove.filter(b => !b.driver);
                if (safeToRemove.length > 0) {
                    Composite.remove(world, safeToRemove);
                }
            }
        }

        const ragdolls = bodies.filter(b => b.customType === 'ragdoll');
        const interactables = bodies.filter(b => b.customType === 'crate' || b.customType === 'sphere' || b.customType === 'carBody');
        const launchers = bodies.filter(b => b.customType === 'launcher');
        const blackholes = bodies.filter(b => b.customType === 'blackhole');

        if (keys['arrowright'] || keys['d']) {
            // Drive Cars
            bodies.forEach(b => {
                if (b.customType === 'wheel') {
                    b.torque += 0.3 * b.mass; 
                }
            });
            // NEW: Aim Launchers (Rotate Clockwise)
            launchers.forEach(l => {
                Body.setAngularVelocity(l, 0.15);
            });
        }
        if (keys['arrowleft'] || keys['a']) {
            // Drive Cars
            bodies.forEach(b => {
                if (b.customType === 'wheel') {
                    b.torque -= 0.3 * b.mass;
                }
            });
            // NEW: Aim Launchers (Rotate Counter-Clockwise)
            launchers.forEach(l => {
                Body.setAngularVelocity(l, -0.15);
            });
        }

        blackholes.forEach(bh => {
            const gravity = engine.world.gravity;
            Body.applyForce(bh, bh.position, {
                x: 0,
                y: -bh.mass * gravity.y * gravity.scale
            });

            bodies.forEach(other => {
                if (other === bh || other.isStatic || other.customType === 'launcher') return;
                
                const dVec = Vector.sub(bh.position, other.position);
                const dist = Vector.magnitude(dVec);

                if (dist < 800) {
                    const dir = Vector.normalise(dVec);
                    const strength = 0.002 * other.mass * (1000 / (dist + 50)); 
                    
                    Body.applyForce(other, other.position, Vector.mult(dir, strength));

                    if (dist < bh.circleRadius + 15) {
                        if (other.isTarget && !other.isExploding) {
                            const growth = 1.05;
                            Body.scale(bh, growth, growth);
                            bh.circleRadius *= growth; 
                            triggerExplosion(other);
                        }
                    }
                }
            });
        });

        if (keys['1']) {
            launchers.forEach(launcher => fireLauncher(launcher));
        } 
        else if (keys['f']) {
            let targetLauncher = null;
            if (mouseConstraint.body && mouseConstraint.body.customType === 'launcher') {
                targetLauncher = mouseConstraint.body;
            } 
            else if (launchers.length > 0) {
                let minDist = Infinity;
                launchers.forEach(l => {
                    const dist = Vector.magnitude(Vector.sub(mouse.position, l.position));
                    if (dist < minDist) {
                        minDist = dist;
                        targetLauncher = l;
                    }
                });
            }
            if (targetLauncher) fireLauncher(targetLauncher);
        }

        ragdolls.forEach(body => {
            if (!body.ai) return;
            const ai = body.ai;

            const isGrabbed = mouseConstraint.body && mouseConstraint.body.groupId === body.groupId;
            
            if (ai.state === 'panic') {
                if (ai.talkText === "" || ai.talkText === "Hmm..." || ai.talkText.includes("Hi")) {
                     const panicLines = ["AHHH!", "RUN!", "HELP!", "WOAH!", "NOOO!", "IT'S OVER!", "YIKES!"];
                     ai.talkText = panicLines[Math.floor(Math.random() * panicLines.length)];
                }
                if (ai.fearTarget) {
                    const dx = body.position.x - ai.fearTarget.x;
                    ai.direction = dx > 0 ? 1 : -1; 
                }
                if (time > ai.nextActionTime) {
                    ai.state = 'walk';
                    ai.talkText = ""; 
                }
            }
            else if (isGrabbed) {
                ai.state = 'scared';
                if (Math.random() < (ai.personality === 'timid' ? 0.6 : 0.1)) {
                     Body.applyForce(body, body.position, { x: (Math.random()-0.5)*0.02, y: (Math.random()-0.5)*0.02 });
                }
            } 
            else if (ai.state === 'scared') {
                ai.state = 'walk'; 
            }

            if (ai.personality === 'timid' && ai.state === 'walk') {
                for (let obj of interactables) {
                    const dist = Vector.magnitude(Vector.sub(body.position, obj.position));
                    if (dist < 150 && obj.speed > 8) { 
                        ai.state = 'panic';
                        ai.nextActionTime = time + 2000; 
                        ai.fearTarget = obj.position; 
                        const timidLines = ["Too fast!", "Scary!", "Stay back!", "Oh my...", "Eek!", "Danger!"];
                        ai.talkText = timidLines[Math.floor(Math.random() * timidLines.length)];
                    }
                }
            }

            if (ai.personality === 'explorer' && ai.state === 'walk' && !ai.targetBody && time > ai.nextActionTime) {
                let closest = null;
                let minDist = 600; 
                for (let obj of interactables) {
                    const dist = Vector.magnitude(Vector.sub(body.position, obj.position));
                    if (dist < minDist) {
                        minDist = dist;
                        closest = obj;
                    }
                }
                if (closest) {
                    ai.targetBody = closest;
                    ai.nextActionTime = time + 5000; 
                }
            }
            
            if (ai.targetBody && ai.state === 'walk') {
                if (Composite.allBodies(world).includes(ai.targetBody)) {
                    const dx = ai.targetBody.position.x - body.position.x;
                    ai.direction = dx > 0 ? 1 : -1;
                    if (Math.abs(dx) < 40 || time > ai.nextActionTime) {
                        ai.targetBody = null;
                        const exploreLines = ["Hmm...", "Interesting.", "What is that?", "Shiny...", "Analyzing...", "Curious.", "Nice."];
                        ai.talkText = exploreLines[Math.floor(Math.random() * exploreLines.length)];
                        setTimeout(() => ai.talkText = "", 1000);
                    }
                } else {
                    ai.targetBody = null; 
                }
            }

            if (ai.state === 'walk' && !ai.vehicle && Math.random() < 0.02) { 
                const cars = interactables.filter(b => b.customType === 'carBody' && !b.driver);
                for (let car of cars) {
                    const dist = Vector.magnitude(Vector.sub(body.position, car.position));
                    if (dist < 120) {
                        ai.state = 'driving';
                        ai.vehicle = car;
                        car.driver = body;
                        ai.talkText = Math.random() > 0.5 ? "Road trip!" : "Vroom!";
                        
                        const seatPos = Vector.add(car.position, {x: 0, y: -20});
                        Body.setPosition(body, seatPos);
                        Body.setVelocity(body, car.velocity); 
                        
                        ai.seatbelt = Constraint.create({
                            bodyA: car, bodyB: body,
                            pointA: {x: 0, y: -15}, pointB: {x: 0, y: 0},
                            stiffness: 0.1, length: 0, render: { visible: false }
                        });
                        Composite.add(world, ai.seatbelt);
                        break;
                    }
                }
            }
            
            if (ai.state === 'driving' && ai.vehicle) {
                if (!Composite.allBodies(world).includes(ai.vehicle)) {
                    ai.state = 'walk';
                    ai.vehicle = null;
                    if (ai.seatbelt) Composite.remove(world, ai.seatbelt);
                    return;
                }
                
                if (time > ai.nextActionTime) {
                    ai.direction = Math.random() > 0.5 ? 1 : -1;
                    ai.nextActionTime = time + 2000 + Math.random() * 3000;
                    if (Math.random() < 0.3) ai.talkText = "Beep beep!";
                    else ai.talkText = "";
                }
                
                if (ai.vehicle.wheels) {
                    ai.vehicle.wheels.forEach(w => {
                        w.torque += 0.25 * w.mass * ai.direction;
                    });
                }
                
                if (body.relatedHead) {
                    Body.setAngle(body.relatedHead, 0); 
                }
                
                return; 
            }

            const angleSpeed = body.angularVelocity;
            const targetAngle = 0;
            const torque = 0.5 * (targetAngle - body.angle) - 2 * angleSpeed;
            body.torque += torque * body.mass;

            if (body.relatedHead) {
                const hAngle = body.relatedHead.angle;
                const hSpeed = body.relatedHead.angularVelocity;
                const hTorque = 0.1 * (0 - hAngle) - 0.5 * hSpeed;
                body.relatedHead.torque += hTorque * body.relatedHead.mass;
            }

            if ((ai.state === 'walk' || ai.state === 'panic') && body.legs) {
                const walkSpeed = ai.state === 'panic' ? 0.015 : 0.008;
                const stride = 0.8; 
                
                const targetRight = Math.sin(time * walkSpeed) * stride;
                const targetLeft = Math.sin(time * walkSpeed + Math.PI) * stride;
                
                const kLeg = 0.15; 
                
                const rAngle = body.legs.right.angle - body.angle;
                const rTorque = kLeg * (targetRight - rAngle);
                body.legs.right.torque += rTorque * body.legs.right.mass;
                
                const lAngle = body.legs.left.angle - body.angle;
                const lTorque = kLeg * (targetLeft - lAngle);
                body.legs.left.torque += lTorque * body.legs.left.mass;
            }

            if (ai.personality === 'social' && ai.state === 'walk' && ai.socialCooldown <= 0) {
                for (let other of ragdolls) {
                    if (other === body || other.ai.state !== 'walk') continue;
                    const dist = Vector.magnitude(Vector.sub(body.position, other.position));
                    if (dist < 80) {
                        const greetings = ["Hi friend!", "Greetings!", "Hello!", "Hey there!", "Nice pixels!", "Physics is fun!", "Don't push me!", "Lovely day!"];
                        const replies = ["Good day!", "Hi!", "Yo!", "Physics rules!", "Indeed!", "Stay safe!", "I'm walking here!", "Cool!"];
                        
                        ai.state = 'talk';
                        ai.talkDuration = 150;
                        ai.talkText = greetings[Math.floor(Math.random() * greetings.length)];
                        ai.socialCooldown = 800;

                        other.ai.state = 'talk';
                        other.ai.talkDuration = 150;
                        other.ai.talkText = replies[Math.floor(Math.random() * replies.length)];
                        other.ai.socialCooldown = 800;
                        break;
                    }
                }
            }

            if (ai.state === 'talk') {
                ai.talkDuration--;
                if (ai.talkDuration <= 0) {
                    ai.state = 'walk';
                    ai.direction *= -1; 
                }
                return; 
            }

            if (ai.socialCooldown > 0) ai.socialCooldown--;

            if (ai.state === 'walk' || ai.state === 'panic') {
                if (ai.state === 'walk' && !ai.targetBody && time > ai.nextActionTime) {
                    if (Math.random() < 0.3) ai.direction *= -1;
                    ai.nextActionTime = time + 2000 + Math.random() * 2000;
                }

                const speed = ai.state === 'panic' ? 0.005 : 0.0025;
                Body.applyForce(body, body.position, { x: speed * ai.direction * body.mass, y: 0 });

                if (Math.abs(body.velocity.x) < 0.3) {
                    ai.isStuckCount++;
                    if (ai.isStuckCount > 30) {
                        Body.applyForce(body, body.position, { x: 0, y: -0.02 * body.mass });
                        if (ai.isStuckCount > 80) {
                            ai.direction *= -1;
                            ai.isStuckCount = 0;
                            if (ai.targetBody) ai.targetBody = null; 
                        }
                    }
                } else {
                    ai.isStuckCount = 0;
                }
            }
        });
    });

    // --- NEW: VISUAL EFFECTS SYSTEM ---
    function addShockwave(x, y) {
        vfx.push({ type: 'shockwave', x: x, y: y, r: 10, opacity: 1.0 });
    }
    
    function addFlash() {
        vfx.push({ type: 'flash', opacity: 0.6 });
    }
    
    function createDebris(x, y, color, count = 5) { 
        const particles = [];
        for (let i = 0; i < count; i++) {
            const size = 5 + Math.random() * 6; 
            const particle = Bodies.polygon(x, y, 3 + Math.floor(Math.random() * 2), size, {
                render: { fillStyle: color },
                friction: 0.5,
                restitution: 0.5,
                frictionAir: 0.08 
            });
            const force = {
                x: (Math.random() - 0.5) * 0.02,
                y: (Math.random() - 0.5) * 0.02 - 0.02
            };
            Body.applyForce(particle, particle.position, force);
            particles.push(particle);
        }
        Composite.add(world, particles);
        setTimeout(() => Composite.remove(world, particles), 1000);
    }
    
    function createSparks(x, y, count = 3) {
         for (let i=0; i<count; i++) {
             vfx.push({
                 type: 'spark',
                 x: x,
                 y: y,
                 vx: (Math.random() - 0.5) * 10,
                 vy: (Math.random() - 0.5) * 10,
                 life: 15,
                 color: Math.random() > 0.5 ? '#fde047' : '#ffffff' // Yellow/White
             });
         }
    }

    // --- Custom Texture Renderer ---
    Events.on(render, 'afterRender', function() {
        const ctx = render.context;
        const bodies = Composite.allBodies(world);
        const time = engine.timing.timestamp;

        // --- DRAW VFX (On top) ---
        for (let i = vfx.length - 1; i >= 0; i--) {
            const e = vfx[i];
            
            if (e.type === 'shockwave') {
                e.r += 15;
                e.opacity -= 0.05;
                if (e.opacity <= 0) { vfx.splice(i, 1); continue; }
                
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 255, 255, ${e.opacity})`;
                ctx.lineWidth = 10 * e.opacity;
                ctx.stroke();
            } 
            else if (e.type === 'flash') {
                e.opacity -= 0.1;
                if (e.opacity <= 0) { vfx.splice(i, 1); continue; }
                
                ctx.fillStyle = `rgba(255, 255, 255, ${e.opacity})`;
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            }
            else if (e.type === 'spark') {
                e.x += e.vx;
                e.y += e.vy;
                e.vy += 0.5; // Gravity
                e.life--;
                if (e.life <= 0) { vfx.splice(i, 1); continue; }
                
                ctx.fillStyle = e.color;
                ctx.fillRect(e.x, e.y, 2, 2);
            }
        }

        // --- FPS COUNTER LOGIC ---
        if (!window.fpsFrameCount) {
            window.fpsFrameCount = 0;
            window.fpsLastTime = performance.now();
            window.fpsElem = document.getElementById('fps-counter');
        }
        
        window.fpsFrameCount++;
        const now = performance.now();
        if (now - window.fpsLastTime >= 1000) {
            const fps = Math.round((window.fpsFrameCount * 1000) / (now - window.fpsLastTime));
            if (window.fpsElem) window.fpsElem.innerText = 'FPS: ' + fps;
            window.fpsFrameCount = 0;
            window.fpsLastTime = now;
        }

        const itemElem = document.getElementById('item-counter');
        if (itemElem && window.fpsFrameCount % 10 === 0) { 
             const count = Composite.allBodies(world).filter(b => !b.isStatic).length;
             itemElem.innerText = 'Items: ' + count;
        }
        
        for (let i = 0; i < bodies.length; i += 1) {
            const body = bodies[i];

            if (body.entityType === 'projectile') {
                if (!body.trail) body.trail = [];
                body.trail.push({ x: body.position.x, y: body.position.y });
                if (body.trail.length > 20) body.trail.shift();

                if (body.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(body.trail[0].x, body.trail[0].y);
                    for (let j = 1; j < body.trail.length; j++) {
                        ctx.lineTo(body.trail[j].x, body.trail[j].y);
                    }
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ef4444';
                    ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    
                    ctx.strokeStyle = 'rgba(255, 200, 200, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }

            const x = body.position.x;
            const y = body.position.y;
            const angle = body.angle;

            ctx.translate(x, y);
            ctx.rotate(angle);

            if (body.customType === 'crate') {
                const w = body.bounds.max.x - body.bounds.min.x;
                const h = body.bounds.max.y - body.bounds.min.y;
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 3;
                ctx.strokeRect(-w/2 + 4, -h/2 + 4, w - 8, h - 8);
                ctx.beginPath();
                ctx.moveTo(-w/2 + 4, -h/2 + 4); ctx.lineTo(w/2 - 4, h/2 - 4);
                ctx.moveTo(w/2 - 4, -h/2 + 4); ctx.lineTo(-w/2 + 4, h/2 - 4);
                ctx.stroke();
            }
            if (body.customType === 'heavyBlock') {
                const w = body.bounds.max.x - body.bounds.min.x;
                const h = body.bounds.max.y - body.bounds.min.y;
                
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                ctx.beginPath();
                ctx.moveTo(-w/2, -h/2 + 20);
                ctx.lineTo(-w/2 + 20, -h/2);
                ctx.lineTo(w/2, h/2 - 20);
                ctx.lineTo(w/2 - 20, h/2);
                ctx.fill();

                ctx.fillStyle = '#334155';
                const inset = 8;
                const rivetSize = 3;
                const positions = [
                    {x: -w/2 + inset, y: -h/2 + inset},
                    {x: w/2 - inset, y: -h/2 + inset},
                    {x: w/2 - inset, y: h/2 - inset},
                    {x: -w/2 + inset, y: h/2 - inset}
                ];
                
                positions.forEach(pos => {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, rivetSize, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
                
                ctx.strokeStyle = '#475569';
                ctx.lineWidth = 3;
                ctx.strokeRect(-w/2, -h/2, w, h);
            }
            if (body.customType === 'blackhole') {
                const r = body.circleRadius;
                
                const pulse = Math.sin(time * 0.005) * 0.1 + 1;
                const pulse2 = Math.cos(time * 0.008) * 0.1 + 1;

                const gradient = ctx.createRadialGradient(0, 0, r, 0, 0, r * 3 * pulse);
                gradient.addColorStop(0, 'rgba(139, 92, 246, 0.4)'); 
                gradient.addColorStop(1, 'rgba(139, 92, 246, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, r * 3 * pulse, 0, 2 * Math.PI);
                ctx.fill();

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, r + (5 * pulse2), 0, 2 * Math.PI);
                ctx.stroke();

                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(0, 0, r, 0, 2 * Math.PI);
                ctx.fill();
            }
            if (body.customType === 'water') {
                const r = body.circleRadius;
                
                ctx.fillStyle = 'rgba(56, 189, 248, 0.55)';
                ctx.beginPath();
                ctx.arc(0, 0, r * 1.3, 0, 2 * Math.PI);
                ctx.fill();

                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(-r * 0.3, -r * 0.3, r * 0.5, 0, 2 * Math.PI);
                ctx.fill();
            }
            if (body.customType === 'wheel') {
                const r = body.circleRadius;
                ctx.strokeStyle = '#555'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, r - 2, 0, 2 * Math.PI); ctx.stroke();
                ctx.fillStyle = '#777'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, 2 * Math.PI); ctx.fill();
                ctx.strokeStyle = '#555'; ctx.beginPath();
                ctx.moveTo(0, -r+2); ctx.lineTo(0, r-2);
                ctx.moveTo(-r+2, 0); ctx.lineTo(r-2, 0);
                ctx.stroke();
            }
            if (body.customType === 'carBody') {
                ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(-10, -10); ctx.lineTo(-10, 10); ctx.stroke();
                ctx.fillStyle = '#fef08a'; ctx.beginPath(); ctx.rect(40, -5, 5, 10); ctx.fill();
                ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.rect(-48, -5, 5, 10); ctx.fill();
            }
            if (body.customType === 'launcher') {
                ctx.fillStyle = '#ef4444'; 
                ctx.beginPath(); 
                ctx.rect(10, -10, 5, 20); 
                ctx.fill();
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.rect(25, -12, 4, 4);
                ctx.fill();
            }
            if (body.customType === 'face') {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                
                let state = 'walk';
                if (body.relatedTorso && body.relatedTorso.ai) {
                    state = body.relatedTorso.ai.state;
                }

                ctx.beginPath();
                if (state === 'scared' || state === 'panic') {
                    ctx.fillStyle = 'white';
                    ctx.arc(-4, -2, 2.5, 0, 2 * Math.PI); ctx.arc(4, -2, 2.5, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-4, -2, 1, 0, 2 * Math.PI); ctx.arc(4, -2, 1, 0, 2 * Math.PI); ctx.fill();
                } else {
                    ctx.arc(-4, -2, 1.5, 0, 2 * Math.PI); ctx.arc(4, -2, 1.5, 0, 2 * Math.PI); ctx.fill();
                }

                ctx.beginPath();
                ctx.strokeStyle = 'rgba(0,0,0,0.6)';
                ctx.lineWidth = 1;
                if (state === 'scared' || state === 'panic') {
                    ctx.ellipse(0, 3, 2, 3, 0, 0, 2 * Math.PI); 
                    ctx.stroke();
                } else if (state === 'talk') {
                    ctx.moveTo(-2, 3); ctx.lineTo(2, 3);
                    ctx.stroke();
                } else {
                    ctx.arc(0, 2, 5, 0.2, Math.PI - 0.2); 
                    ctx.stroke();
                }
            }

            if (body.isTarget && body.tapCount > 0) {
                const health = body.tapCount;
                ctx.globalAlpha = health * 0.2;
                ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0,0); ctx.lineTo(10, 10); ctx.lineTo(15, -5); ctx.lineTo(-10, -10);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            ctx.rotate(-angle);
            ctx.translate(-x, -y);

            if (body.customType === 'face' && body.relatedTorso && body.relatedTorso.ai) {
                const ai = body.relatedTorso.ai;
                if (ai.state === 'talk' || ai.state === 'panic') {
                    const text = ai.talkText || "";
                    if (text !== "") {
                        ctx.save();
                        ctx.translate(body.position.x, body.position.y - 35);
                        
                        ctx.font = '14px "Segoe UI", sans-serif';
                        const textMetrics = ctx.measureText(text);
                        const textWidth = textMetrics.width;
                        const boxPadding = 8;
                        const boxWidth = textWidth + (boxPadding * 2);
                        const boxHeight = 26;

                        ctx.fillStyle = 'white';
                        ctx.strokeStyle = '#ccc';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.roundRect(-boxWidth/2, -boxHeight/2 - 5, boxWidth, boxHeight, 5);
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(0, boxHeight/2 - 5);
                        ctx.lineTo(-4, boxHeight/2 + 2);
                        ctx.lineTo(4, boxHeight/2 - 5);
                        ctx.fill();

                        ctx.fillStyle = 'black';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(text, 0, -5);
                        ctx.restore();
                    }
                }
            }
        }
        
        if (isSlowMotion) {
            ctx.save();
            ctx.font = '900 24px "Segoe UI", sans-serif';
            ctx.fillStyle = '#38bdf8';
            ctx.strokeStyle = '#0f172a';
            ctx.lineWidth = 4;
            ctx.textAlign = 'center';
            ctx.strokeText("SLOW MOTION", render.canvas.width / 2, 50);
            ctx.fillText("SLOW MOTION", render.canvas.width / 2, 50);
            ctx.restore();
        }
    });

    Events.on(render, 'beforeRender', function() {
        const ctx = render.context;
        const width = render.canvas.width;
        const height = render.canvas.height;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1;
        const gridSize = 50;
        ctx.beginPath();
        for (let x = 0; x < width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
        for (let y = 0; y < height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
        ctx.stroke();
    });

    const mouse = Mouse.create(render.canvas);
    mouse.pixelRatio = window.devicePixelRatio || 1;
    const mouseConstraint = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: { 
            stiffness: 0.5,
            render: { visible: false } 
        }
    });
    Composite.add(world, mouseConstraint);
    render.mouse = mouse;

    let dragDistance = 0;
    
    Events.on(mouseConstraint, 'mousedown', () => { 
        dragDistance = 0; 
        
        if (currentSpawnType === 'delete') {
            const body = mouseConstraint.body;
            if (body && !body.isStatic) {
                Composite.remove(world, body);
                createDebris(body.position.x, body.position.y, body.render.fillStyle || '#fff', 5);
                mouseConstraint.body = null;
            }
        }
    });
    
    Events.on(mouseConstraint, 'mousemove', () => { if (mouseConstraint.body) dragDistance++; });
    Events.on(mouseConstraint, 'mouseup', () => {
        const body = mouseConstraint.body;
        if (currentSpawnType !== 'delete' && body && body.isTarget && dragDistance < 12) {
            handleTap(body);
        }
    });

    // --- Hard Collision Detection (Updated for Sound) ---
    Events.on(engine, 'collisionStart', (event) => {
        const pairs = event.pairs;
        const now = Date.now();
        const IMPACT_THRESHOLD = 8; 
        
        for (let i = 0; i < pairs.length; i++) {
            const pair = pairs[i];
            const bodyA = pair.bodyA;
            const bodyB = pair.bodyB;

            // --- PROJECTILE LOGIC ---
            if (bodyA.entityType === 'projectile' || bodyB.entityType === 'projectile') {
                const projectile = bodyA.entityType === 'projectile' ? bodyA : bodyB;
                const target = bodyA === projectile ? bodyB : bodyA;

                if (target.customType === 'blackhole') {
                    const growth = 1.01;
                    Body.scale(target, growth, growth);
                    target.circleRadius *= growth;
                    Composite.remove(world, projectile);
                    continue;
                }

                if (target.isTarget && !target.isStatic && !target.isExploding && target.customType !== 'blackhole') {
                    triggerExplosion(target);
                    Composite.remove(world, projectile);
                    createDebris(projectile.position.x, projectile.position.y, '#ef4444', 3);
                    continue; 
                }
            }

            const relativeMotion = Vector.sub(bodyA.velocity, bodyB.velocity);
            const speed = Vector.magnitude(relativeMotion);

            // --- NEW: IMPACT SOUNDS & SPARKS ---
            if (speed > 1.5) {
                // Determine material type
                let type = 'wood';
                if (bodyA.customType === 'heavyBlock' || bodyB.customType === 'heavyBlock' || 
                    bodyA.customType === 'carBody' || bodyB.customType === 'carBody' ||
                    bodyA.customType === 'launcher' || bodyB.customType === 'launcher') {
                    type = 'metal';
                }
                
                playImpactSound(speed, type);

                // Create Sparks for Metal-on-Metal or High Speed Metal
                if (type === 'metal' && speed > 5) {
                    const contact = pair.contacts[0];
                    if (contact) {
                        createSparks(contact.vertex.x, contact.vertex.y, Math.floor(speed / 2));
                    }
                }
            }

            if (speed > 24) {
                if (bodyA.isTarget && !bodyA.isExploding && now - (bodyA.createdAt || 0) > 1000) {
                    triggerExplosion(bodyA);
                }
                if (bodyB.isTarget && !bodyB.isExploding && now - (bodyB.createdAt || 0) > 1000) {
                    triggerExplosion(bodyB);
                }
            }
        }
    });

    window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            togglePause();
            return;
        }

        if (e.key.toLowerCase() === 'm') {
            document.body.classList.toggle('gui-hidden');
        }

        if (!isGameRunning) return;

        if (e.key.toLowerCase() === 't') {
            isSlowMotion = !isSlowMotion;
            engine.timing.timeScale = isSlowMotion ? 0.2 : 1.0;
        }

        if (e.key.toLowerCase() === 'e') {
            if (currentSpawnType === 'delete') {
                const bodies = Composite.allBodies(world);
                const found = Matter.Query.point(bodies, mouse.position);
                if (found.length > 0) {
                    const body = found[0];
                    if (!body.isStatic) {
                        Composite.remove(world, body);
                        createDebris(body.position.x, body.position.y, body.render.fillStyle || '#fff', 5);
                    }
                }
            } else {
                const countSlider = document.getElementById('count-slider');
                const count = parseInt(countSlider.value);
                
                for (let i = 0; i < count; i++) {
                    const jitter = count > 1 ? 50 : 0; 
                    const offX = (Math.random() - 0.5) * jitter;
                    const offY = (Math.random() - 0.5) * jitter;
                    
                    spawnEntity(currentSpawnType, mouse.position.x + offX, mouse.position.y + offY);
                }
            }
        }
        
        if (e.key === '2') clearAllShapes();

        if (e.key === '3') {
             const targets = Composite.allBodies(world).filter(b => b.isTarget && !b.isStatic && !b.isExploding);
             targets.forEach(body => triggerExplosion(body));
        }
        
        if (e.key.toLowerCase() === 'f') {
            const bodies = Composite.allBodies(world);
            const launcher = bodies.find(b => b.customType === 'launcher');
            
            if (launcher) {
                playShootSound();
                
                const len = 35;
                const angle = launcher.angle;
                const barrelX = launcher.position.x + Math.cos(angle) * len;
                const barrelY = launcher.position.y + Math.sin(angle) * len;
                
                const projectile = Bodies.circle(barrelX, barrelY, 6, {
                    density: 0.05,
                    restitution: 0.5,
                    render: { fillStyle: '#ef4444' }
                });
                
                const force = 0.05;
                Body.applyForce(projectile, projectile.position, {
                    x: Math.cos(angle) * force,
                    y: Math.sin(angle) * force
                });
                
                projectile.isTarget = true; 
                projectile.tapCount = 5; 
                projectile.groupId = Math.random().toString(36).substr(2, 9);
                projectile.entityType = 'projectile';
                
                Composite.add(world, projectile);
                
                Body.applyForce(launcher, launcher.position, {
                    x: -Math.cos(angle) * 0.05,
                    y: -Math.sin(angle) * 0.05
                });
            }
        }
    });

    const gravitySlider = document.getElementById('gravity-slider');
    const gravityVal = document.getElementById('gravity-val');

    function updateFriction(isZeroG) {
        const bodies = Composite.allBodies(world);
        bodies.forEach(body => {
            if (isZeroG) {
                if (typeof body.originalFrictionAir === 'undefined') {
                    body.originalFrictionAir = body.frictionAir;
                }
                body.frictionAir = 0; 
            } else {
                if (typeof body.originalFrictionAir !== 'undefined') {
                    body.frictionAir = body.originalFrictionAir;
                }
            }
        });
    }

    gravitySlider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        engine.gravity.y = val;
        gravityVal.innerText = val.toFixed(1);
        updateFriction(val === 0);
    });

    Events.on(world, 'afterAdd', (event) => {
        if (engine.gravity.y === 0) {
            const objects = Array.isArray(event.object) ? event.object : [event.object];
            objects.forEach(obj => {
                if (obj.type === 'body') {
                    if (typeof obj.originalFrictionAir === 'undefined') {
                        obj.originalFrictionAir = obj.frictionAir;
                    }
                    obj.frictionAir = 0;
                }
            });
        }
    });

    const sizeSlider = document.getElementById('size-slider');
    const sizeVal = document.getElementById('size-val');
    sizeSlider.addEventListener('input', (e) => {
        spawnScale = parseFloat(e.target.value);
        sizeVal.innerText = spawnScale.toFixed(1) + 'x';
    });

    const countSlider = document.getElementById('count-slider');
    const countVal = document.getElementById('count-val');
    countSlider.addEventListener('input', (e) => {
        countVal.innerText = e.target.value;
    });

    const fpsSlider = document.getElementById('fps-slider');
    const fpsVal = document.getElementById('fps-val');
    fpsSlider.addEventListener('input', (e) => {
        const val = parseInt(e.target.value);
        if (val >= 150) {
            targetFPS = 999; 
            fpsVal.innerText = "MAX";
            frameInterval = 0;
        } else {
            targetFPS = val;
            fpsVal.innerText = val;
            frameInterval = 1000 / targetFPS;
        }
    });

    // NEW: Explosion Power Slider Logic
    const powerSlider = document.getElementById('power-slider');
    const powerVal = document.getElementById('power-val');
    powerSlider.addEventListener('input', (e) => {
        explosionPower = parseFloat(e.target.value);
        powerVal.innerText = explosionPower.toFixed(1) + 'x';
    });

    // NEW: Explosion Range Slider Logic
    const rangeSlider = document.getElementById('range-slider');
    const rangeVal = document.getElementById('range-val');
    rangeSlider.addEventListener('input', (e) => {
        explosionRange = parseInt(e.target.value);
        rangeVal.innerText = explosionRange;
    });

    let isLimitActive = true;
    const limitToggle = document.getElementById('limit-toggle');
    limitToggle.addEventListener('change', (e) => {
        isLimitActive = e.target.checked;
    });

    function clearAllShapes() {
        const bodies = Composite.allBodies(world);
        const toRemove = bodies.filter(b => !b.isStatic);
        Composite.remove(world, toRemove);
        const constraints = Composite.allConstraints(world);
        const nonMouseConstraints = constraints.filter(c => c !== mouseConstraint.constraint);
        Composite.remove(world, nonMouseConstraints);
    }

    function handleTap(body) {
        body.tapCount++;
        Body.scale(body, 0.95, 0.95);
        setTimeout(() => Body.scale(body, 1.0526, 1.0526), 50);
        if (body.tapCount >= 5) triggerExplosion(body);
    }

    const respawnQueue = new Set();

    function triggerExplosion(sourceBody) {
        if (sourceBody.isExploding) return;
        
        if (sourceBody.isStatic || !sourceBody.groupId || sourceBody.customType === 'blackhole' || sourceBody.entityType === 'blackhole' || sourceBody.customType === 'water') return;

        playExplosionSound();
        
        // ADD VFX
        addShockwave(sourceBody.position.x, sourceBody.position.y);
        addFlash();
        
        // UPDATED: Dynamic Screen Shake Calculation
        // Shake scales with Power and Range
        // Base: ~20. Max Power (30) + Max Range (1500) -> ~80 shake intensity
        shakeIntensity = (explosionPower * 1.5) + (explosionRange / 40); 

        const groupId = sourceBody.groupId;
        const allBodies = Composite.allBodies(world);
        const groupBodies = allBodies.filter(b => b.groupId === groupId && !b.isStatic);
        
        groupBodies.forEach(b => b.isExploding = true);

        const pos = { x: sourceBody.position.x, y: sourceBody.position.y };
        const color = sourceBody.render.fillStyle;
        const spawnType = sourceBody.entityType; 

        // Flash Background
        render.options.background = '#e2e8f0';
        setTimeout(() => render.options.background = '#0f172a', 60);

        const ragdolls = allBodies.filter(b => b.customType === 'ragdoll');
        ragdolls.forEach(ragdoll => {
            if (ragdoll.ai && !ragdoll.isExploding) {
                const dist = Vector.magnitude(Vector.sub(ragdoll.position, pos));
                // UPDATED: Panic range scales with explosion range
                if (dist < explosionRange * 0.8) {
                    ragdoll.ai.state = 'panic';
                    ragdoll.ai.fearTarget = pos;
                    ragdoll.ai.nextActionTime = Date.now() + 2500; 
                }
            }
        });

        Composite.allBodies(world).forEach(body => {
            if (body.isStatic || body.groupId === groupId) return; 
            const distVec = Vector.sub(body.position, pos);
            const dist = Vector.magnitude(distVec);
            
            // UPDATED: Use dynamic range and power
            if (dist < explosionRange) {
                // 0.3 base force * power multiplier * falloff based on new range
                const forceMag = 0.3 * explosionPower * Math.pow((explosionRange - dist) / explosionRange, 2);
                const force = Vector.mult(Vector.normalise(distVec), forceMag * body.mass);
                Body.applyForce(body, body.position, force);
                Body.setAngularVelocity(body, (Math.random() - 0.5) * 0.5);
            }
        });

        createDebris(pos.x, pos.y, color);

        Composite.remove(world, groupBodies);
        
        const constraints = Composite.allConstraints(world);
        const groupConstraints = constraints.filter(c => 
            c !== mouseConstraint.constraint && 
            ((c.bodyA && c.bodyA.groupId === groupId) || 
            (c.bodyB && c.bodyB.groupId === groupId))
        );
        Composite.remove(world, groupConstraints);
        
        if (mouseConstraint.body && mouseConstraint.body.groupId === groupId) {
            mouseConstraint.constraint.bodyB = null;
            mouseConstraint.body = null;
        }

        if (spawnType && spawnType !== 'projectile' && !respawnQueue.has(groupId)) {
            respawnQueue.add(groupId);
            setTimeout(() => {
                const respawnX = Math.max(50, Math.min(window.innerWidth - 50, pos.x));
                spawnEntity(spawnType, respawnX, window.innerHeight - 150);
                respawnQueue.delete(groupId); 
            }, 1000);
        }
    }

    for (let i = 0; i < 4; i++) {
        spawnEntity('block');
        spawnEntity('person');
    }

    window.addEventListener('resize', () => {
        render.canvas.width = window.innerWidth; render.canvas.height = window.innerHeight;
        render.options.width = window.innerWidth; render.options.height = window.innerHeight;
        Mouse.setElement(mouse, render.canvas);
        mouse.pixelRatio = window.devicePixelRatio || 1;
        createWalls();
    });

    window.spawnEntity = spawnEntity;
    window.selectAndSpawn = selectAndSpawn;
    window.clearAllShapes = clearAllShapes;

    // --- NEW: EDITABLE VALUES HELPER ---
    function setupEditable(spanId, sliderId, suffix, callback) {
        const span = document.getElementById(spanId);
        const slider = document.getElementById(sliderId);
        
        span.classList.add('editable-val');
        span.title = "Click to edit value";

        span.addEventListener('click', (e) => {
            if (span.querySelector('input')) return;
            
            const text = span.innerText.replace(suffix, '').replace('MAX', '150');
            const oldVal = parseFloat(text);
            
            const input = document.createElement('input');
            input.type = 'number';
            input.value = oldVal;
            input.className = 'value-input';
            
            input.addEventListener('click', (e) => e.stopPropagation());
            
            const save = () => {
                let newVal = parseFloat(input.value);
                if (isNaN(newVal)) newVal = oldVal;
                
                // Allow extending slider range if user inputs big number
                if (newVal > parseFloat(slider.max)) slider.max = newVal;
                if (newVal < parseFloat(slider.min)) slider.min = newVal;
                
                slider.value = newVal;
                
                // Run specific update logic
                callback(newVal);
                
                // Restore text
                if (sliderId === 'fps-slider' && newVal >= 150) {
                    span.innerText = "MAX";
                } else {
                    if (newVal % 1 !== 0) span.innerText = newVal.toFixed(1) + suffix;
                    else span.innerText = newVal + suffix;
                }
            };

            input.addEventListener('blur', save);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') input.blur();
            });

            span.innerText = '';
            span.appendChild(input);
            input.focus();
        });
    }

    // --- SETUP EDITABLE VALUES ---
    setupEditable('gravity-val', 'gravity-slider', '', (val) => {
        engine.gravity.y = val; 
        updateFriction(val === 0);
    });

    setupEditable('size-val', 'size-slider', 'x', (val) => {
        spawnScale = val;
    });

    setupEditable('count-val', 'count-slider', '', (val) => {
        // Slider value already updated in helper
    });

    setupEditable('fps-val', 'fps-slider', '', (val) => {
        if (val >= 150) {
            targetFPS = 999;
            frameInterval = 0;
        } else {
            targetFPS = val;
            frameInterval = 1000 / targetFPS;
        }
    });

    setupEditable('power-val', 'power-slider', 'x', (val) => {
        explosionPower = val;
    });

    setupEditable('range-val', 'range-slider', '', (val) => {
        explosionRange = val;
    });

</script>
</body>
</html>
